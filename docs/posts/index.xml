<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on kflansburg.com</title>
    <link>https://kflansburg.com/posts/</link>
    <description>Recent content in Posts on kflansburg.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Kevin Flansburg</copyright>
    <lastBuildDate>Mon, 18 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://kflansburg.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Selecting a Framework</title>
      <link>https://kflansburg.com/posts/ordered-stateful-streaming/selecting-a-framework/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/ordered-stateful-streaming/selecting-a-framework/</guid>
      <description>&lt;p&gt;In the second post of this series I explore the strengths and weaknesses of
several popular streaming frameworks. This analysis was performed a couple of
years ago with a particular application in mind. These frameworks have since
improved, but this post should provide some insight into the tradeoffs and
decisions involved when designing streaming applications, and lessons can be
learned from choices that did and did not pay off.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://kflansburg.com/posts/ordered-stateful-streaming/introduction/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/ordered-stateful-streaming/introduction/</guid>
      <description>&lt;p&gt;I recently spent two weeks tracking down a subtle bug in a Spark Structured
Streaming application which I have been maintaining for several years. Having
dealt with many such time-consuming bugs over the years, I&amp;rsquo;ve decided to
compile my experiences working with ordered, stateful streaming applications
into a series of posts. This series will serve as an introductory guide to the
design and operation of stateful streaming pipelines, and hopefully spur some
further development to simplify this process in the future.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rust Continuous Delivery</title>
      <link>https://kflansburg.com/posts/rust-continuous-delivery/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/rust-continuous-delivery/</guid>
      <description>&lt;p&gt;Over the last few years I have iterated several times on continuous delivery
pipelines for Rust applications. Designing these pipelines involves balancing
a number of factors including cost, complexity, ergonomics, and rigor. In this
post I will describe several of these iterations, lessons learned, and share my
most recent solution in detail.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Fistful of States: More State Machine Patterns in Rust</title>
      <link>https://kflansburg.com/posts/a-fistful-of-states/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/a-fistful-of-states/</guid>
      <description>My recent guest post on Deis Labs&#39; Blog offers a deep dive into my work on Krustlet, including the design and implementation of a flexible state machine API for specifying custom Kubelet behavior in a type-safe framework.</description>
    </item>
    
  </channel>
</rss>
