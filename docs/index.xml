<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kflansburg.com</title>
    <link>https://kflansburg.com/</link>
    <description>Recent content on kflansburg.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Kevin Flansburg</copyright>
    <lastBuildDate>Sat, 05 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://kflansburg.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WIT Resources</title>
      <link>https://kflansburg.com/posts/wit-resources/</link>
      <pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/wit-resources/</guid>
      <description>&lt;p&gt;Support for &amp;ldquo;resources&amp;rdquo; &lt;a href=&#34;https://github.com/bytecodealliance/wit-bindgen/commit/62f3f649e38ed4f111729595ce32ee0308ab0f7c&#34;&gt;just landed&lt;/a&gt;
in the &lt;code&gt;wit-bindgen&lt;/code&gt; repository. This post explores why resources are crucial
for writing rich, object-oriented APIs in WIT.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Thoughts on WIT and wit-bindgen</title>
      <link>https://kflansburg.com/posts/wit-and-wit-bindgen-thoughts/</link>
      <pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/wit-and-wit-bindgen-thoughts/</guid>
      <description>&lt;p&gt;The Wasm component model uses WIT to define runtime APIs available to guest
components. &lt;code&gt;wit-bindgen&lt;/code&gt; can then be used by both guest component authors
and host platforms to generate bindings in their language of choice to
consume or implement these runtime APIs respectively. This post discusses
some of the rough edges encountered when taking this for a spin.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Merge Queues with Bors</title>
      <link>https://kflansburg.com/posts/merge-queues/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/merge-queues/</guid>
      <description>&lt;p&gt;Many engineering teams and open source projects are introducing merge queues as
part of their workflows. This post explores several reasons for using a merge
queue and describes how to set up Bors, the merge queue implementation used by
the Rust language project.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Speed up Rust Builds with Cachepot</title>
      <link>https://kflansburg.com/posts/rust-cachepot/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/rust-cachepot/</guid>
      <description>&lt;p&gt;One of the most effective ways for speeding up Rust builds is to cache the
compiled artifacts of crate dependencies. Cargo does this automatically for
local builds, but this quickly breaks down for distributed scenarios.&lt;/p&gt;
&lt;p&gt;In this post, I will share my experiences with configuring and using Cachepot,
a tool which wraps the Rust compiler and automatically caches build artifacts
using a variety of cloud storage options. This creates a cache which can be
shared amongst teams, used in ephemeral CI/CD environments, and even used for
distributed builds.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Krator: My God, it&#39;s Full of States!</title>
      <link>https://kflansburg.com/posts/introducing-krator/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/introducing-krator/</guid>
      <description>At the beginning of February, I published my second guest post on Deis Labs&amp;rsquo; blog, which introduced Krator. Pronounced &amp;ldquo;crater&amp;rdquo;, this crate allows you to build Kubernetes Operators in Rust, using the state machine API that we designed for Krustlet last year. Check out the post for an example of writing an Operator with this crate!</description>
    </item>
    
    <item>
      <title>Rust Continuous Delivery</title>
      <link>https://kflansburg.com/posts/rust-continuous-delivery/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/rust-continuous-delivery/</guid>
      <description>&lt;p&gt;Over the last few years I have iterated several times on continuous delivery
pipelines for Rust applications. Designing these pipelines involves balancing
a number of factors including cost, complexity, ergonomics, and rigor. In this
post I will describe several of these iterations, lessons learned, and share my
most recent solution in detail.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Fistful of States: More State Machine Patterns in Rust</title>
      <link>https://kflansburg.com/posts/a-fistful-of-states/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/a-fistful-of-states/</guid>
      <description>My recent guest post on Deis Labs&amp;rsquo; blog offers a deep dive into my work on Krustlet, including the design and implementation of a flexible state machine API for specifying custom Kubelet behavior in a type-safe framework.</description>
    </item>
    
  </channel>
</rss>
